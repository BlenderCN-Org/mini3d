
// -- THIS FILE IS AUTOGENERATED USING THE SCRIPT GLWRAPPERS.PY --

// Copyright (c) <2012> Daniel Peterson
// This file is part of Mini3D <www.mini3d.org>
// It is distributed under the MIT Software License <www.mini3d.org/license.php>


#if defined(__linux__) && !defined(ANDROID)

#include <X11/Xlib.h>
#include <GL/gl.h>
#include <GL/glx.h>
#include "../common/glext.h"
#include <GL/glxext.h>
#include "../openglwrapper.hpp"


void mini3d_assert(bool expression, const char* text, ...);

using namespace mini3d::graphics;

struct OpenGlWrapper::Internal
{
    ////////// OPENGL 1.0 ///////////

    ////////// OPENGL 1.2 ///////////
    PFNGLDRAWRANGEELEMENTSPROC _glDrawRangeElements;

    ////////// OPENGL 1.3 ///////////
    PFNGLACTIVETEXTUREPROC _glActiveTexture;
    PFNGLGENERATEMIPMAPPROC _glGenerateMipmap;
    PFNGLCOMPRESSEDTEXIMAGE2DPROC _glCompressedTexImage2D;
    PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC _glCompressedTexSubImage2D;

    ////////// OPENGL 1.5 ///////////
    PFNGLDELETEBUFFERSPROC _glDeleteBuffers;
    PFNGLGENBUFFERSPROC _glGenBuffers;
    PFNGLBINDBUFFERPROC _glBindBuffer;
    PFNGLMAPBUFFERPROC _glMapBuffer;
    PFNGLUNMAPBUFFERPROC _glUnmapBuffer;
    PFNGLBUFFERDATAPROC _glBufferData;
    PFNGLGETBUFFERSUBDATAPROC _glGetBufferSubData;

    ////////// OPENGL 2.0 ///////////
    PFNGLISSHADERPROC _glIsShader;
    PFNGLCREATESHADERPROC _glCreateShader;
    PFNGLDELETESHADERPROC _glDeleteShader;
    PFNGLATTACHSHADERPROC _glAttachShader;
    PFNGLSHADERSOURCEPROC _glShaderSource;
    PFNGLGETSHADERSOURCEPROC _glGetShaderSource;
    PFNGLCOMPILESHADERPROC _glCompileShader;
    PFNGLGETSHADERIVPROC _glGetShaderiv;
    PFNGLGETSHADERINFOLOGPROC _glGetShaderInfoLog;
    PFNGLCREATEPROGRAMPROC _glCreateProgram;
    PFNGLDELETEPROGRAMPROC _glDeleteProgram;
    PFNGLLINKPROGRAMPROC _glLinkProgram;
    PFNGLUSEPROGRAMPROC _glUseProgram;
    PFNGLGETPROGRAMIVPROC _glGetProgramiv;
    PFNGLGETPROGRAMINFOLOGPROC _glGetProgramInfoLog;
    PFNGLVALIDATEPROGRAMPROC _glValidateProgram;
    PFNGLGETATTRIBLOCATIONPROC _glGetAttribLocation;
    PFNGLBINDATTRIBLOCATIONPROC _glBindAttribLocation;
    PFNGLGETACTIVEATTRIBPROC _glGetActiveAttrib;
    PFNGLUNIFORM1FPROC _glUniform1f;
    PFNGLUNIFORM2FPROC _glUniform2f;
    PFNGLUNIFORM3FPROC _glUniform3f;
    PFNGLUNIFORM4FPROC _glUniform4f;
    PFNGLUNIFORM4FVPROC _glUniform4fv;
    PFNGLUNIFORM1IPROC _glUniform1i;
    PFNGLUNIFORM2IPROC _glUniform2i;
    PFNGLUNIFORM3IPROC _glUniform3i;
    PFNGLUNIFORM4IPROC _glUniform4i;
    PFNGLUNIFORM4IVPROC _glUniform4iv;
    PFNGLUNIFORMMATRIX4FVPROC _glUniformMatrix4fv;
    PFNGLGETUNIFORMLOCATIONPROC _glGetUniformLocation;
    PFNGLGETACTIVEUNIFORMPROC _glGetActiveUniform;
    PFNGLVERTEXATTRIBPOINTERPROC _glVertexAttribPointer;
    PFNGLDISABLEVERTEXATTRIBARRAYPROC _glDisableVertexAttribArray;
    PFNGLENABLEVERTEXATTRIBARRAYPROC _glEnableVertexAttribArray;

    ////////// OPENGL 3.1 ///////////
    PFNGLDRAWELEMENTSINSTANCEDPROC _glDrawElementsInstanced;

    ////////// OPENGL 3.3 ///////////
    PFNGLVERTEXATTRIBDIVISORPROC _glVertexAttribDivisor;

    ////////// OPENGL 4.2 ///////////
    PFNGLGENRENDERBUFFERSPROC _glGenRenderbuffers;
    PFNGLGENRENDERBUFFERSEXTPROC _glGenRenderbuffersEXT;
    PFNGLBINDRENDERBUFFERPROC _glBindRenderbuffer;
    PFNGLBINDRENDERBUFFEREXTPROC _glBindRenderbufferEXT;
    PFNGLDELETERENDERBUFFERSPROC _glDeleteRenderbuffers;
    PFNGLDELETERENDERBUFFERSEXTPROC _glDeleteRenderbuffersEXT;
    PFNGLRENDERBUFFERSTORAGEPROC _glRenderbufferStorage;
    PFNGLRENDERBUFFERSTORAGEEXTPROC _glRenderbufferStorageEXT;
    PFNGLGENFRAMEBUFFERSPROC _glGenFramebuffers;
    PFNGLGENFRAMEBUFFERSEXTPROC _glGenFramebuffersEXT;
    PFNGLBINDFRAMEBUFFERPROC _glBindFramebuffer;
    PFNGLBINDFRAMEBUFFEREXTPROC _glBindFramebufferEXT;
    PFNGLDELETEFRAMEBUFFERSPROC _glDeleteFramebuffers;
    PFNGLDELETEFRAMEBUFFERSEXTPROC _glDeleteFramebuffersEXT;
    PFNGLCHECKFRAMEBUFFERSTATUSPROC _glCheckFramebufferStatus;
    PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC _glCheckFramebufferStatusEXT;
    PFNGLFRAMEBUFFERTEXTURE2DPROC _glFramebufferTexture2D;
    PFNGLFRAMEBUFFERTEXTURE2DEXTPROC _glFramebufferTexture2DEXT;
    PFNGLFRAMEBUFFERRENDERBUFFERPROC _glFramebufferRenderbuffer;
    PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC _glFramebufferRenderbufferEXT;
};

OpenGlWrapper::OpenGlWrapper()
{

    mpI = new Internal();

    ////////// OPENGL 1.0 ///////////

    ////////// OPENGL 1.2 ///////////
    mpI->_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)glXGetProcAddress((const GLubyte*)"glDrawRangeElements");

    ////////// OPENGL 1.3 ///////////
    mpI->_glActiveTexture = (PFNGLACTIVETEXTUREPROC)glXGetProcAddress((const GLubyte*)"glActiveTexture");
    mpI->_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)glXGetProcAddress((const GLubyte*)"glGenerateMipmap");
    mpI->_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)glXGetProcAddress((const GLubyte*)"glCompressedTexImage2D");
    mpI->_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)glXGetProcAddress((const GLubyte*)"glCompressedTexSubImage2D");

    ////////// OPENGL 1.5 ///////////
    mpI->_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glDeleteBuffers");
    mpI->_glGenBuffers = (PFNGLGENBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glGenBuffers");
    mpI->_glBindBuffer = (PFNGLBINDBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBindBuffer");
    mpI->_glMapBuffer = (PFNGLMAPBUFFERPROC)glXGetProcAddress((const GLubyte*)"glMapBuffer");
    mpI->_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)glXGetProcAddress((const GLubyte*)"glUnmapBuffer");
    mpI->_glBufferData = (PFNGLBUFFERDATAPROC)glXGetProcAddress((const GLubyte*)"glBufferData");
    mpI->_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)glXGetProcAddress((const GLubyte*)"glGetBufferSubData");

    ////////// OPENGL 2.0 ///////////
    mpI->_glIsShader = (PFNGLISSHADERPROC)glXGetProcAddress((const GLubyte*)"glIsShader");
    mpI->_glCreateShader = (PFNGLCREATESHADERPROC)glXGetProcAddress((const GLubyte*)"glCreateShader");
    mpI->_glDeleteShader = (PFNGLDELETESHADERPROC)glXGetProcAddress((const GLubyte*)"glDeleteShader");
    mpI->_glAttachShader = (PFNGLATTACHSHADERPROC)glXGetProcAddress((const GLubyte*)"glAttachShader");
    mpI->_glShaderSource = (PFNGLSHADERSOURCEPROC)glXGetProcAddress((const GLubyte*)"glShaderSource");
    mpI->_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)glXGetProcAddress((const GLubyte*)"glGetShaderSource");
    mpI->_glCompileShader = (PFNGLCOMPILESHADERPROC)glXGetProcAddress((const GLubyte*)"glCompileShader");
    mpI->_glGetShaderiv = (PFNGLGETSHADERIVPROC)glXGetProcAddress((const GLubyte*)"glGetShaderiv");
    mpI->_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glXGetProcAddress((const GLubyte*)"glGetShaderInfoLog");
    mpI->_glCreateProgram = (PFNGLCREATEPROGRAMPROC)glXGetProcAddress((const GLubyte*)"glCreateProgram");
    mpI->_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)glXGetProcAddress((const GLubyte*)"glDeleteProgram");
    mpI->_glLinkProgram = (PFNGLLINKPROGRAMPROC)glXGetProcAddress((const GLubyte*)"glLinkProgram");
    mpI->_glUseProgram = (PFNGLUSEPROGRAMPROC)glXGetProcAddress((const GLubyte*)"glUseProgram");
    mpI->_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)glXGetProcAddress((const GLubyte*)"glGetProgramiv");
    mpI->_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)glXGetProcAddress((const GLubyte*)"glGetProgramInfoLog");
    mpI->_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)glXGetProcAddress((const GLubyte*)"glValidateProgram");
    mpI->_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)glXGetProcAddress((const GLubyte*)"glGetAttribLocation");
    mpI->_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)glXGetProcAddress((const GLubyte*)"glBindAttribLocation");
    mpI->_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)glXGetProcAddress((const GLubyte*)"glGetActiveAttrib");
    mpI->_glUniform1f = (PFNGLUNIFORM1FPROC)glXGetProcAddress((const GLubyte*)"glUniform1f");
    mpI->_glUniform2f = (PFNGLUNIFORM2FPROC)glXGetProcAddress((const GLubyte*)"glUniform2f");
    mpI->_glUniform3f = (PFNGLUNIFORM3FPROC)glXGetProcAddress((const GLubyte*)"glUniform3f");
    mpI->_glUniform4f = (PFNGLUNIFORM4FPROC)glXGetProcAddress((const GLubyte*)"glUniform4f");
    mpI->_glUniform4fv = (PFNGLUNIFORM4FVPROC)glXGetProcAddress((const GLubyte*)"glUniform4fv");
    mpI->_glUniform1i = (PFNGLUNIFORM1IPROC)glXGetProcAddress((const GLubyte*)"glUniform1i");
    mpI->_glUniform2i = (PFNGLUNIFORM2IPROC)glXGetProcAddress((const GLubyte*)"glUniform2i");
    mpI->_glUniform3i = (PFNGLUNIFORM3IPROC)glXGetProcAddress((const GLubyte*)"glUniform3i");
    mpI->_glUniform4i = (PFNGLUNIFORM4IPROC)glXGetProcAddress((const GLubyte*)"glUniform4i");
    mpI->_glUniform4iv = (PFNGLUNIFORM4IVPROC)glXGetProcAddress((const GLubyte*)"glUniform4iv");
    mpI->_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)glXGetProcAddress((const GLubyte*)"glUniformMatrix4fv");
    mpI->_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)glXGetProcAddress((const GLubyte*)"glGetUniformLocation");
    mpI->_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)glXGetProcAddress((const GLubyte*)"glGetActiveUniform");
    mpI->_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glXGetProcAddress((const GLubyte*)"glVertexAttribPointer");
    mpI->_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)glXGetProcAddress((const GLubyte*)"glDisableVertexAttribArray");
    mpI->_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glXGetProcAddress((const GLubyte*)"glEnableVertexAttribArray");

    ////////// OPENGL 3.1 ///////////
    mpI->_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)glXGetProcAddress((const GLubyte*)"glDrawElementsInstanced");

    ////////// OPENGL 3.3 ///////////
    mpI->_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)glXGetProcAddress((const GLubyte*)"glVertexAttribDivisor");

    ////////// OPENGL 4.2 ///////////
    mpI->_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glGenRenderbuffers");
    mpI->_glGenRenderbuffersEXT = (PFNGLGENRENDERBUFFERSEXTPROC)glXGetProcAddress((const GLubyte*)"glGenRenderbuffers");
    mpI->_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBindRenderbuffer");
    mpI->_glBindRenderbufferEXT = (PFNGLBINDRENDERBUFFEREXTPROC)glXGetProcAddress((const GLubyte*)"glBindRenderbuffer");
    mpI->_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glDeleteRenderbuffers");
    mpI->_glDeleteRenderbuffersEXT = (PFNGLDELETERENDERBUFFERSEXTPROC)glXGetProcAddress((const GLubyte*)"glDeleteRenderbuffers");
    mpI->_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)glXGetProcAddress((const GLubyte*)"glRenderbufferStorage");
    mpI->_glRenderbufferStorageEXT = (PFNGLRENDERBUFFERSTORAGEEXTPROC)glXGetProcAddress((const GLubyte*)"glRenderbufferStorage");
    mpI->_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glGenFramebuffers");
    mpI->_glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC)glXGetProcAddress((const GLubyte*)"glGenFramebuffers");
    mpI->_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBindFramebuffer");
    mpI->_glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC)glXGetProcAddress((const GLubyte*)"glBindFramebuffer");
    mpI->_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glDeleteFramebuffers");
    mpI->_glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC)glXGetProcAddress((const GLubyte*)"glDeleteFramebuffers");
    mpI->_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)glXGetProcAddress((const GLubyte*)"glCheckFramebufferStatus");
    mpI->_glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)glXGetProcAddress((const GLubyte*)"glCheckFramebufferStatus");
    mpI->_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTexture2D");
    mpI->_glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTexture2D");
    mpI->_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)glXGetProcAddress((const GLubyte*)"glFramebufferRenderbuffer");
    mpI->_glFramebufferRenderbufferEXT = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)glXGetProcAddress((const GLubyte*)"glFramebufferRenderbuffer");
}

    ////////// OPENGL 1.0 ///////////
GLenum OpenGlWrapper::glGetError() { return ::glGetError(); }
const GLubyte* OpenGlWrapper::glGetString(GLenum name) { return ::glGetString(name); }
void OpenGlWrapper::glBindTexture(GLenum target, GLuint texture) { ::glBindTexture(target, texture); }
void OpenGlWrapper::glTexParameteri(GLenum target, GLenum pname, GLint param) { ::glTexParameteri(target, pname, param); }
void OpenGlWrapper::glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) { ::glGetTexParameteriv(target, pname, params); }
void OpenGlWrapper::glGenTextures(GLsizei n, GLuint *textures) { ::glGenTextures(n, textures); }
void OpenGlWrapper::glDeleteTextures(GLsizei n, const GLuint *textures) { ::glDeleteTextures(n, textures); }
void OpenGlWrapper::glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) { ::glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels); }
void OpenGlWrapper::glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) { ::glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels); }
void OpenGlWrapper::glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *img) { ::glGetTexImage(target, level, format, type, img); }
void OpenGlWrapper::glDrawBuffer(GLenum mode) { ::glDrawBuffer(mode); }
void OpenGlWrapper::glReadBuffer(GLenum mode) { ::glReadBuffer(mode); }
void OpenGlWrapper::glEnable(GLenum cap) { ::glEnable(cap); }
void OpenGlWrapper::glDisable(GLenum cap) { ::glDisable(cap); }
void OpenGlWrapper::glClear(GLbitfield mask) { ::glClear(mask); }
void OpenGlWrapper::glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) { ::glClearColor(red, green, blue, alpha); }
void OpenGlWrapper::glClearDepth(GLclampd depth) { ::glClearDepth(depth); }
void OpenGlWrapper::glShadeModel(GLenum mode) { ::glShadeModel(mode); }
void OpenGlWrapper::glDepthFunc(GLenum func) { ::glDepthFunc(func); }
void OpenGlWrapper::glGetIntegerv(GLenum pname, GLint *params) { ::glGetIntegerv(pname, params); }
void OpenGlWrapper::glCullFace(GLenum mode) { ::glCullFace(mode); }
void OpenGlWrapper::glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) { ::glDrawElements(mode, count, type, indices); }
void OpenGlWrapper::glViewport(GLint x, GLint y, GLsizei width, GLsizei height) { ::glViewport(x, y, width, height); }

    ////////// OPENGL 1.2 ///////////
void OpenGlWrapper::glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) { mpI->_glDrawRangeElements(mode, start, end, count, type, indices); }

    ////////// OPENGL 1.3 ///////////
void OpenGlWrapper::glActiveTexture(GLenum texture) { mpI->_glActiveTexture(texture); }
void OpenGlWrapper::glGenerateMipmap(GLenum target) { mpI->_glGenerateMipmap(target); }
void OpenGlWrapper::glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data) { mpI->_glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data); }
void OpenGlWrapper::glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data) { mpI->_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data); }

    ////////// OPENGL 1.5 ///////////
void OpenGlWrapper::glDeleteBuffers(GLsizei n, const GLuint *buffers) { mpI->_glDeleteBuffers(n, buffers); }
void OpenGlWrapper::glGenBuffers(GLsizei n, GLuint *buffers) { mpI->_glGenBuffers(n, buffers); }
void OpenGlWrapper::glBindBuffer(GLenum target, GLuint buffer) { mpI->_glBindBuffer(target, buffer); }
GLvoid* OpenGlWrapper::glMapBuffer(GLenum target, GLenum access) { return mpI->_glMapBuffer(target, access); }
GLboolean OpenGlWrapper::glUnmapBuffer(GLenum target) { return mpI->_glUnmapBuffer(target); }
void OpenGlWrapper::glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage) { mpI->_glBufferData(target, size, data, usage); }
void OpenGlWrapper::glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data) { mpI->_glGetBufferSubData(target, offset, size, data); }

    ////////// OPENGL 2.0 ///////////
GLboolean OpenGlWrapper::glIsShader(GLuint shader) { return mpI->_glIsShader(shader); }
GLuint OpenGlWrapper::glCreateShader(GLenum type) { return mpI->_glCreateShader(type); }
void OpenGlWrapper::glDeleteShader(GLuint shader) { mpI->_glDeleteShader(shader); }
void OpenGlWrapper::glAttachShader(GLuint program, GLuint shader) { mpI->_glAttachShader(program, shader); }
void OpenGlWrapper::glShaderSource(GLuint shader, GLsizei count, const GLchar* *string, const GLint *length) { mpI->_glShaderSource(shader, count, string, length); }
void OpenGlWrapper::glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source) { mpI->_glGetShaderSource(shader, bufSize, length, source); }
void OpenGlWrapper::glCompileShader(GLuint shader) { mpI->_glCompileShader(shader); }
void OpenGlWrapper::glGetShaderiv(GLuint shader, GLenum pname, GLint *params) { mpI->_glGetShaderiv(shader, pname, params); }
void OpenGlWrapper::glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog) { mpI->_glGetShaderInfoLog(shader, bufSize, length, infoLog); }
GLuint OpenGlWrapper::glCreateProgram() { return mpI->_glCreateProgram(); }
void OpenGlWrapper::glDeleteProgram(GLuint program) { mpI->_glDeleteProgram(program); }
void OpenGlWrapper::glLinkProgram(GLuint program) { mpI->_glLinkProgram(program); }
void OpenGlWrapper::glUseProgram(GLuint program) { mpI->_glUseProgram(program); }
void OpenGlWrapper::glGetProgramiv(GLuint program, GLenum pname, GLint *params) { mpI->_glGetProgramiv(program, pname, params); }
void OpenGlWrapper::glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog) { mpI->_glGetProgramInfoLog(program, bufSize, length, infoLog); }
void OpenGlWrapper::glValidateProgram(GLuint program) { mpI->_glValidateProgram(program); }
GLint OpenGlWrapper::glGetAttribLocation(GLuint program, const GLchar *name) { return mpI->_glGetAttribLocation(program, name); }
void OpenGlWrapper::glBindAttribLocation(GLuint program, GLuint index, const GLchar *name) { mpI->_glBindAttribLocation(program, index, name); }
void OpenGlWrapper::glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) { mpI->_glGetActiveAttrib(program, index, bufSize, length, size, type, name); }
void OpenGlWrapper::glUniform1f(GLint location, GLfloat v0) { mpI->_glUniform1f(location, v0); }
void OpenGlWrapper::glUniform2f(GLint location, GLfloat v0, GLfloat v1) { mpI->_glUniform2f(location, v0, v1); }
void OpenGlWrapper::glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) { mpI->_glUniform3f(location, v0, v1, v2); }
void OpenGlWrapper::glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) { mpI->_glUniform4f(location, v0, v1, v2, v3); }
void OpenGlWrapper::glUniform4fv(GLint location, GLsizei count, const GLfloat *value) { mpI->_glUniform4fv(location, count, value); }
void OpenGlWrapper::glUniform1i(GLint location, GLint v0) { mpI->_glUniform1i(location, v0); }
void OpenGlWrapper::glUniform2i(GLint location, GLint v0, GLint v1) { mpI->_glUniform2i(location, v0, v1); }
void OpenGlWrapper::glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) { mpI->_glUniform3i(location, v0, v1, v2); }
void OpenGlWrapper::glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) { mpI->_glUniform4i(location, v0, v1, v2, v3); }
void OpenGlWrapper::glUniform4iv(GLint location, GLsizei count, const GLint *value) { mpI->_glUniform4iv(location, count, value); }
void OpenGlWrapper::glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) { mpI->_glUniformMatrix4fv(location, count, transpose, value); }
GLint OpenGlWrapper::glGetUniformLocation(GLuint program, const GLchar *name) { return mpI->_glGetUniformLocation(program, name); }
void OpenGlWrapper::glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) { mpI->_glGetActiveUniform(program, index, bufSize, length, size, type, name); }
void OpenGlWrapper::glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer) { mpI->_glVertexAttribPointer(index, size, type, normalized, stride, pointer); }
void OpenGlWrapper::glDisableVertexAttribArray(GLuint index) { mpI->_glDisableVertexAttribArray(index); }
void OpenGlWrapper::glEnableVertexAttribArray(GLuint index) { mpI->_glEnableVertexAttribArray(index); }

    ////////// OPENGL 3.1 ///////////
void OpenGlWrapper::glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount) { mpI->_glDrawElementsInstanced(mode, count, type, indices, primcount); }

    ////////// OPENGL 3.3 ///////////
void OpenGlWrapper::glVertexAttribDivisor(GLuint index, GLuint divisor) { mpI->_glVertexAttribDivisor(index, divisor); }

    ////////// OPENGL 4.2 ///////////
void OpenGlWrapper::glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
    if (mpI->_glGenRenderbuffers)  mpI->_glGenRenderbuffers(n, renderbuffers);
    else if (mpI->_glGenRenderbuffersEXT)  mpI->_glGenRenderbuffersEXT(n, renderbuffers);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
    if (mpI->_glBindRenderbuffer)  mpI->_glBindRenderbuffer(target, renderbuffer);
    else if (mpI->_glBindRenderbufferEXT)  mpI->_glBindRenderbufferEXT(target, renderbuffer);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
    if (mpI->_glDeleteRenderbuffers)  mpI->_glDeleteRenderbuffers(n, renderbuffers);
    else if (mpI->_glDeleteRenderbuffersEXT)  mpI->_glDeleteRenderbuffersEXT(n, renderbuffers);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
    if (mpI->_glRenderbufferStorage)  mpI->_glRenderbufferStorage(target, internalformat, width, height);
    else if (mpI->_glRenderbufferStorageEXT)  mpI->_glRenderbufferStorageEXT(target, internalformat, width, height);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
    if (mpI->_glGenFramebuffers)  mpI->_glGenFramebuffers(n, framebuffers);
    else if (mpI->_glGenFramebuffersEXT)  mpI->_glGenFramebuffersEXT(n, framebuffers);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glBindFramebuffer(GLenum target, GLuint framebuffer)
{
    if (mpI->_glBindFramebuffer)  mpI->_glBindFramebuffer(target, framebuffer);
    else if (mpI->_glBindFramebufferEXT)  mpI->_glBindFramebufferEXT(target, framebuffer);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
    if (mpI->_glDeleteFramebuffers)  mpI->_glDeleteFramebuffers(n, framebuffers);
    else if (mpI->_glDeleteFramebuffersEXT)  mpI->_glDeleteFramebuffersEXT(n, framebuffers);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

GLenum OpenGlWrapper::glCheckFramebufferStatus(GLenum target)
{
    if (mpI->_glCheckFramebufferStatus) return mpI->_glCheckFramebufferStatus(target);
    else if (mpI->_glCheckFramebufferStatusEXT) return mpI->_glCheckFramebufferStatusEXT(target);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
    return 0;
}

void OpenGlWrapper::glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    if (mpI->_glFramebufferTexture2D)  mpI->_glFramebufferTexture2D(target, attachment, textarget, texture, level);
    else if (mpI->_glFramebufferTexture2DEXT)  mpI->_glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}

void OpenGlWrapper::glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    if (mpI->_glFramebufferRenderbuffer)  mpI->_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    else if (mpI->_glFramebufferRenderbufferEXT)  mpI->_glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    else mini3d_assert(false, "OpenGL driver does not support EXT_framebuffer_object");
}


#endif
