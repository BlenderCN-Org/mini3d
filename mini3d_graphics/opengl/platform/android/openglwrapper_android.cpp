
// -- THIS FILE IS AUTOGENERATED USING THE SCRIPT GLWRAPPERS.PY --

// Copyright (c) <2012> Daniel Peterson
// This file is part of Mini3D <www.mini3d.org>
// It is distributed under the MIT Software License <www.mini3d.org/license.php>


#ifdef __ANDROID__

#define GL_GLEXT_FUNCTION_POINTERS 1
#include "../openglwrapper.hpp"
#include <GLES2/gl2.h>

void mini3d_assert(bool expression, const char* text, ...);

namespace mini3d {
namespace graphics {

void initOpenGL() {};

////////// OPENGL 1.0 ///////////
GLenum glGetError() { return ::glGetError(); }
const GLubyte* glGetString(GLenum name) { return ::glGetString(name); }
void glBindTexture(GLenum target, GLuint texture) { ::glBindTexture(target, texture); }
void glTexParameteri(GLenum target, GLenum pname, GLint param) { ::glTexParameteri(target, pname, param); }
void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) { ::glGetTexParameteriv(target, pname, params); }
void glGenTextures(GLsizei n, GLuint *textures) { ::glGenTextures(n, textures); }
void glDeleteTextures(GLsizei n, const GLuint *textures) { ::glDeleteTextures(n, textures); }
void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) { ::glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels); }
void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) { ::glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels); }
void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *img) {  }
void glDrawBuffer(GLenum mode) {  }
void glReadBuffer(GLenum mode) {  }
void glEnable(GLenum cap) { ::glEnable(cap); }
void glDisable(GLenum cap) { ::glDisable(cap); }
void glClear(GLbitfield mask) { ::glClear(mask); }
void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) { ::glClearColor(red, green, blue, alpha); }
void glClearDepth(GLclampf depth) { ::glClearDepthf(depth); }
void glShadeModel(GLenum mode) { }
void glDepthFunc(GLenum func) { ::glDepthFunc(func); }
void glGetIntegerv(GLenum pname, GLint *params) { ::glGetIntegerv(pname, params); }
void glCullFace(GLenum mode) { ::glCullFace(mode); }
void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) { ::glDrawElements(mode, count, type, indices); }
void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) { ::glViewport(x, y, width, height); }

////////// OPENGL 1.2 ///////////
void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) { ::glDrawElements(mode, count, type, indices); }

////////// OPENGL 1.3 ///////////
void glActiveTexture(GLenum texture) { ::glActiveTexture(texture); }
void glGenerateMipmap(GLenum target) { ::glGenerateMipmap(target); }
void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data) { ::glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data); }
void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data) { ::glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data); }

////////// OPENGL 1.5 ///////////
void glDeleteBuffers(GLsizei n, const GLuint *buffers) { ::glDeleteBuffers(n, buffers); }
void glGenBuffers(GLsizei n, GLuint *buffers) { ::glGenBuffers(n, buffers); }
void glBindBuffer(GLenum target, GLuint buffer) { ::glBindBuffer(target, buffer); }
GLvoid* glMapBuffer(GLenum target, GLenum access) {  }
GLboolean glUnmapBuffer(GLenum target) { }
void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage) { ::glBufferData(target, size, data, usage); }
void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data) { }

////////// OPENGL 2.0 ///////////
GLboolean glIsShader(GLuint shader) { return ::glIsShader(shader); }
GLuint glCreateShader(GLenum type) { return ::glCreateShader(type); }
void glDeleteShader(GLuint shader) { ::glDeleteShader(shader); }
void glAttachShader(GLuint program, GLuint shader) { ::glAttachShader(program, shader); }
void glShaderSource(GLuint shader, GLsizei count, const GLchar* *string, const GLint *length) { ::glShaderSource(shader, count, string, length); }
void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source) { ::glGetShaderSource(shader, bufSize, length, source); }
void glCompileShader(GLuint shader) { ::glCompileShader(shader); }
void glGetShaderiv(GLuint shader, GLenum pname, GLint *params) { ::glGetShaderiv(shader, pname, params); }
void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog) { ::glGetShaderInfoLog(shader, bufSize, length, infoLog); }
GLuint glCreateProgram() { return ::glCreateProgram(); }
void glDeleteProgram(GLuint program) { ::glDeleteProgram(program); }
void glLinkProgram(GLuint program) { ::glLinkProgram(program); }
void glUseProgram(GLuint program) { ::glUseProgram(program); }
void glGetProgramiv(GLuint program, GLenum pname, GLint *params) { ::glGetProgramiv(program, pname, params); }
void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog) { ::glGetProgramInfoLog(program, bufSize, length, infoLog); }
void glValidateProgram(GLuint program) { ::glValidateProgram(program); }
GLint glGetAttribLocation(GLuint program, const GLchar *name) { return ::glGetAttribLocation(program, name); }
void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name) { ::glBindAttribLocation(program, index, name); }
void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) { ::glGetActiveAttrib(program, index, bufSize, length, size, type, name); }
void glUniform1fv(GLint location, GLsizei count, const GLfloat *value) { ::glUniform1fv(location, count, value); }
void glUniform2fv(GLint location, GLsizei count, const GLfloat *value) { ::glUniform2fv(location, count, value); }
void glUniform3fv(GLint location, GLsizei count, const GLfloat *value) { ::glUniform3fv(location, count, value); }
void glUniform4fv(GLint location, GLsizei count, const GLfloat *value) { ::glUniform4fv(location, count, value); }
void glUniform1i(GLint location, GLint v0) { ::glUniform1i(location, v0); }
void glUniform2i(GLint location, GLint v0, GLint v1) { ::glUniform2i(location, v0, v1); }
void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) { ::glUniform3i(location, v0, v1, v2); }
void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) { ::glUniform4i(location, v0, v1, v2, v3); }
void glUniform4iv(GLint location, GLsizei count, const GLint *value) { ::glUniform4iv(location, count, value); }
void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) { ::glUniformMatrix4fv(location, count, transpose, value); }
GLint glGetUniformLocation(GLuint program, const GLchar *name) { return ::glGetUniformLocation(program, name); }
void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) { ::glGetActiveUniform(program, index, bufSize, length, size, type, name); }
void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer) { ::glVertexAttribPointer(index, size, type, normalized, stride, pointer); }
void glDisableVertexAttribArray(GLuint index) { ::glDisableVertexAttribArray(index); }
void glEnableVertexAttribArray(GLuint index) { ::glEnableVertexAttribArray(index); }

////////// OPENGL 3.1 ///////////
void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount) { }

////////// OPENGL 3.3 ///////////
void glVertexAttribDivisor(GLuint index, GLuint divisor) { }

////////// OPENGL 4.2 ///////////
void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
::glGenRenderbuffers(n, renderbuffers);
}

void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
::glBindRenderbuffer(target, renderbuffer);
}

void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
::glDeleteRenderbuffers(n, renderbuffers);
}

void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
::glRenderbufferStorage(target, internalformat, width, height);
}

void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
::glGenFramebuffers(n, framebuffers);
}

void glBindFramebuffer(GLenum target, GLuint framebuffer)
{
::glBindFramebuffer(target, framebuffer);
}

void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
::glDeleteFramebuffers(n, framebuffers);
}

GLenum glCheckFramebufferStatus(GLenum target)
{
return ::glCheckFramebufferStatus(target);
}

void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
::glFramebufferTexture2D(target, attachment, textarget, texture, level);
}

void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
::glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

}
}

#endif
